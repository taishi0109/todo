.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Redis 3"
.TH Redis 3 "2020-08-18" "perl v5.30.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Redis \- Perl binding for Redis database
.SH "VERSION"
.IX Header "VERSION"
version 1.998
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    ## Defaults to $ENV{REDIS_SERVER} or 127.0.0.1:6379
\&    my $redis = Redis\->new;
\&
\&    my $redis = Redis\->new(server => \*(Aqredis.example.com:8080\*(Aq);
\&
\&    ## Set the connection name (requires Redis 2.6.9)
\&    my $redis = Redis\->new(
\&      server => \*(Aqredis.example.com:8080\*(Aq,
\&      name => \*(Aqmy_connection_name\*(Aq,
\&    );
\&    my $generation = 0;
\&    my $redis = Redis\->new(
\&      server => \*(Aqredis.example.com:8080\*(Aq,
\&      name => sub { "cache\-$$\-".++$generation },
\&    );
\&
\&    ## Use UNIX domain socket
\&    my $redis = Redis\->new(sock => \*(Aq/path/to/socket\*(Aq);
\&
\&    ## Enable auto\-reconnect
\&    ## Try to reconnect every 1s up to 60 seconds until success
\&    ## Die if you can\*(Aqt after that
\&    my $redis = Redis\->new(reconnect => 60, every => 1_000_000);
\&
\&    ## Try each 100ms up to 2 seconds (every is in microseconds)
\&    my $redis = Redis\->new(reconnect => 2, every => 100_000);
\&
\&    ## Enable connection timeout (in seconds)
\&    my $redis = Redis\->new(cnx_timeout => 60);
\&
\&    ## Enable read timeout (in seconds)
\&    my $redis = Redis\->new(read_timeout => 0.5);
\&
\&    ## Enable write timeout (in seconds)
\&    my $redis = Redis\->new(write_timeout => 1.2);
\&
\&    ## Connect via a list of Sentinels to a given service
\&    my $redis = Redis\->new(sentinels => [ \*(Aq127.0.0.1:12345\*(Aq ], service => \*(Aqmymaster\*(Aq);
\&
\&    ## Same, but with connection, read and write timeout on the sentinel hosts
\&    my $redis = Redis\->new( sentinels => [ \*(Aq127.0.0.1:12345\*(Aq ], service => \*(Aqmymaster\*(Aq,
\&                            sentinels_cnx_timeout => 0.1,
\&                            sentinels_read_timeout => 1,
\&                            sentinels_write_timeout => 1,
\&                          );
\&
\&    ## Use all the regular Redis commands, they all accept a list of
\&    ## arguments
\&    ## See http://redis.io/commands for full list
\&    $redis\->get(\*(Aqkey\*(Aq);
\&    $redis\->set(\*(Aqkey\*(Aq => \*(Aqvalue\*(Aq);
\&    $redis\->sort(\*(Aqlist\*(Aq, \*(AqDESC\*(Aq);
\&    $redis\->sort(qw{list LIMIT 0 5 ALPHA DESC});
\&
\&    ## Add a coderef argument to run a command in the background
\&    $redis\->sort(qw{list LIMIT 0 5 ALPHA DESC}, sub {
\&      my ($reply, $error) = @_;
\&      die "Oops, got an error: $error\en" if defined $error;
\&      print "$_\en" for @$reply;
\&    });
\&    long_computation();
\&    $redis\->wait_all_responses;
\&    ## or
\&    $redis\->wait_one_response();
\&
\&    ## Or run a large batch of commands in a pipeline
\&    my %hash = _get_large_batch_of_commands();
\&    $redis\->hset(\*(Aqh\*(Aq, $_, $hash{$_}, sub {}) for keys %hash;
\&    $redis\->wait_all_responses;
\&
\&    ## Publish/Subscribe
\&    $redis\->subscribe(
\&      \*(Aqtopic_1\*(Aq,
\&      \*(Aqtopic_2\*(Aq,
\&      sub {
\&        my ($message, $topic, $subscribed_topic) = @_
\&
\&          ## $subscribed_topic can be different from topic if
\&          ## you use psubscribe() with wildcards
\&      }
\&    );
\&    $redis\->psubscribe(\*(Aqnasdaq.*\*(Aq, sub {...});
\&
\&    ## Blocks and waits for messages, calls subscribe() callbacks
\&    ##  ... forever
\&    my $timeout = 10;
\&    $redis\->wait_for_messages($timeout) while 1;
\&
\&    ##  ... until some condition
\&    my $keep_going = 1; ## other code will set to false to quit
\&    $redis\->wait_for_messages($timeout) while $keep_going;
\&
\&    $redis\->publish(\*(Aqtopic_1\*(Aq, \*(Aqmessage\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Pure perl bindings for <http://redis.io/>
.PP
This version supports protocol 2.x (multi-bulk) or later of Redis available at
<https://github.com/antirez/redis/>.
.PP
This documentation lists commands which are exercised in test suite, but
additional commands will work correctly since protocol specifies enough
information to support almost all commands with same piece of code with a
little help of \f(CW\*(C`AUTOLOAD\*(C'\fR.
.SH "PIPELINING"
.IX Header "PIPELINING"
Usually, running a command will wait for a response.  However, if you're doing
large numbers of requests, it can be more efficient to use what Redis calls
\&\fIpipelining\fR: send multiple commands to Redis without waiting for a response,
then wait for the responses that come in.
.PP
To use pipelining, add a coderef argument as the last argument to a command
method call:
.PP
.Vb 1
\&  $r\->set(\*(Aqfoo\*(Aq, \*(Aqbar\*(Aq, sub {});
.Ve
.PP
Pending responses to pipelined commands are processed in a single batch, as
soon as at least one of the following conditions holds:
.IP "\(bu" 4
A non-pipelined (synchronous) command is called on the same connection
.IP "\(bu" 4
A pub/sub subscription command (one of \f(CW\*(C`subscribe\*(C'\fR, \f(CW\*(C`unsubscribe\*(C'\fR,
\&\f(CW\*(C`psubscribe\*(C'\fR, or \f(CW\*(C`punsubscribe\*(C'\fR) is about to be called on the same
connection.
.IP "\(bu" 4
One of \*(L"wait_all_responses\*(R" or \*(L"wait_one_response\*(R" methods is called
explicitly.
.PP
The coderef you supply to a pipelined command method is invoked once the
response is available.  It takes two arguments, \f(CW$reply\fR and \f(CW$error\fR.  If
\&\f(CW$error\fR is defined, it contains the text of an error reply sent by the Redis
server.  Otherwise, \f(CW$reply\fR is the non-error reply. For almost all commands,
that means it's \f(CW\*(C`undef\*(C'\fR, or a defined but non-reference scalar, or an array
ref of any of those; but see \*(L"keys\*(R", \*(L"info\*(R", and \*(L"exec\*(R".
.PP
Note the contrast with synchronous commands, which throw an exception on
receipt of an error reply, or return a non-error reply directly.
.PP
The fact that pipelined commands never throw an exception can be particularly
useful for Redis transactions; see \*(L"exec\*(R".
.SH "ENCODING"
.IX Header "ENCODING"
There is no encoding feature anymore, it has been deprecated and finally
removed. This module consider that any data sent to the Redis server is a binary data.
And it doesn't do anything when getting data from the Redis server.
.PP
So, if you are working with character strings, you should pre-encode or post-decode it if needed !
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
.SS "new"
.IX Subsection "new"
.Vb 1
\&    my $r = Redis\->new; # $ENV{REDIS_SERVER} or 127.0.0.1:6379
\&
\&    my $r = Redis\->new( server => \*(Aq192.168.0.1:6379\*(Aq, debug => 0 );
\&    my $r = Redis\->new( server => \*(Aq192.168.0.1:6379\*(Aq, encoding => undef );
\&    my $r = Redis\->new( sock => \*(Aq/path/to/sock\*(Aq );
\&    my $r = Redis\->new( reconnect => 60, every => 5000 );
\&    my $r = Redis\->new( password => \*(Aqboo\*(Aq );
\&    my $r = Redis\->new( on_connect => sub { my ($redis) = @_; ... } );
\&    my $r = Redis\->new( name => \*(Aqmy_connection_name\*(Aq );
\&    my $r = Redis\->new( name => sub { "cache\-for\-$$" });
\&
\&    my $redis = Redis\->new(sentinels => [ \*(Aq127.0.0.1:12345\*(Aq, \*(Aq127.0.0.1:23456\*(Aq ],
\&                           service => \*(Aqmymaster\*(Aq);
\&
\&    ## Connect via a list of Sentinels to a given service
\&    my $redis = Redis\->new(sentinels => [ \*(Aq127.0.0.1:12345\*(Aq ], service => \*(Aqmymaster\*(Aq);
\&
\&    ## Same, but with connection, read and write timeout on the sentinel hosts
\&    my $redis = Redis\->new( sentinels => [ \*(Aq127.0.0.1:12345\*(Aq ], service => \*(Aqmymaster\*(Aq,
\&                            sentinels_cnx_timeout => 0.1,
\&                            sentinels_read_timeout => 1,
\&                            sentinels_write_timeout => 1,
\&                          );
.Ve
.PP
\fI\f(CI\*(C`server\*(C'\fI\fR
.IX Subsection "server"
.PP
The \f(CW\*(C`server\*(C'\fR parameter specifies the Redis server we should connect to,
via \s-1TCP.\s0 Use the '\s-1IP:PORT\s0' format. If no \f(CW\*(C`server\*(C'\fR option is present, we
will attempt to use the \f(CW\*(C`REDIS_SERVER\*(C'\fR environment variable. If neither of
those options are present, it defaults to '127.0.0.1:6379'.
.PP
Alternatively you can use the \f(CW\*(C`sock\*(C'\fR parameter to specify the path of the
\&\s-1UNIX\s0 domain socket where the Redis server is listening.
.PP
Alternatively you can use the \f(CW\*(C`sentinels\*(C'\fR parameter and the \f(CW\*(C`service\*(C'\fR
parameter to specify a list of sentinels to contact and try to get the address
of the given service name. \f(CW\*(C`sentinels\*(C'\fR must be an ArrayRef and \f(CW\*(C`service\*(C'\fR an Str.
.PP
The \f(CW\*(C`REDIS_SERVER\*(C'\fR can be used for \s-1UNIX\s0 domain sockets too. The following
formats are supported:
.IP "\(bu" 4
/path/to/sock
.IP "\(bu" 4
unix:/path/to/sock
.IP "\(bu" 4
127.0.0.1:11011
.IP "\(bu" 4
tcp:127.0.0.1:11011
.PP
\fI\f(CI\*(C`reconnect\*(C'\fI, \f(CI\*(C`every\*(C'\fI\fR
.IX Subsection "reconnect, every"
.PP
The \f(CW\*(C`reconnect\*(C'\fR option enables auto-reconnection mode. If we cannot
connect to the Redis server, or if a network write fails, we enter retry mode.
We will try a new connection every \f(CW\*(C`every\*(C'\fR microseconds (1 ms by
default), up-to \f(CW\*(C`reconnect\*(C'\fR seconds.
.PP
Be aware that read errors will always thrown an exception, and will not trigger
a retry until the new command is sent.
.PP
If we cannot re-establish a connection after \f(CW\*(C`reconnect\*(C'\fR seconds, an
exception will be thrown.
.PP
\fI\f(CI\*(C`conservative_reconnect\*(C'\fI\fR
.IX Subsection "conservative_reconnect"
.PP
\&\f(CW\*(C`conservative_reconnect\*(C'\fR option makes sure that reconnection is only attempted
when no pending command is ongoing. For instance, if you're doing
\&\f(CW\*(C`<$redis\-\*(C'\fRincr('key')>>, and if the server properly understood and processed the
command, but the network connection is dropped just before the server replies :
the command has been processed but the client doesn't know it. In this
situation, if reconnect is enabled, the Redis client will reconnect and send
the \f(CW\*(C`incr\*(C'\fR command *again*. If it succeeds, at the end the key as been
incremented *two* times. To avoid this issue, you can set the \f(CW\*(C`conservative_reconnect\*(C'\fR
option to a true value. In this case, the client will reconnect only if no
request is pending. Otherwise it will die with the message: \f(CW\*(C`reconnect
disabled while responses are pending and safe reconnect mode enabled\*(C'\fR.
.PP
\fI\f(CI\*(C`cnx_timeout\*(C'\fI\fR
.IX Subsection "cnx_timeout"
.PP
The \f(CW\*(C`cnx_timeout\*(C'\fR option enables connection timeout. The Redis client will
wait at most that number of seconds (can be fractional) before giving up
connecting to a server.
.PP
\fI\f(CI\*(C`sentinels_cnx_timeout\*(C'\fI\fR
.IX Subsection "sentinels_cnx_timeout"
.PP
The \f(CW\*(C`sentinels_cnx_timeout\*(C'\fR option enables sentinel connection timeout.
When using the sentinels feature, Redis client will wait at most that number of
seconds (can be fractional) before giving up connecting to a sentinel.
\&\fBDefault\fR: 0.1
.PP
\fI\f(CI\*(C`read_timeout\*(C'\fI\fR
.IX Subsection "read_timeout"
.PP
The \f(CW\*(C`read_timeout\*(C'\fR option enables read timeout. The Redis client will wait
at most that number of seconds (can be fractional) before giving up when
reading from the server.
.PP
\fI\f(CI\*(C`sentinels_read_timeout\*(C'\fI\fR
.IX Subsection "sentinels_read_timeout"
.PP
The \f(CW\*(C`sentinels_read_timeout\*(C'\fR option enables sentinel read timeout. When
using the sentinels feature, the Redis client will wait at most that number of
seconds (can be fractional) before giving up when reading from a sentinel
server. \fBDefault\fR: 1
.PP
\fI\f(CI\*(C`write_timeout\*(C'\fI\fR
.IX Subsection "write_timeout"
.PP
The \f(CW\*(C`write_timeout\*(C'\fR option enables write timeout. The Redis client will wait
at most that number of seconds (can be fractional) before giving up when
reading from the server.
.PP
\fI\f(CI\*(C`sentinels_write_timeout\*(C'\fI\fR
.IX Subsection "sentinels_write_timeout"
.PP
The \f(CW\*(C`sentinels_write_timeout\*(C'\fR option enables sentinel write timeout. When
using the sentinels feature, the Redis client will wait at most that number of
seconds (can be fractional) before giving up when reading from a sentinel
server. \fBDefault\fR: 1
.PP
\fI\f(CI\*(C`password\*(C'\fI\fR
.IX Subsection "password"
.PP
If your Redis server requires authentication, you can use the \f(CW\*(C`password\*(C'\fR
attribute. After each established connection (at the start or when
reconnecting), the Redis \f(CW\*(C`AUTH\*(C'\fR command will be send to the server. If the
password is wrong, an exception will be thrown and reconnect will be disabled.
.PP
\fI\f(CI\*(C`on_connect\*(C'\fI\fR
.IX Subsection "on_connect"
.PP
You can also provide a code reference that will be immediately after each
successful connection. The \f(CW\*(C`on_connect\*(C'\fR attribute is used to provide the
code reference, and it will be called with the first parameter being the Redis
object.
.PP
\fI\f(CI\*(C`no_auto_connect_on_new\*(C'\fI\fR
.IX Subsection "no_auto_connect_on_new"
.PP
You can also provide \f(CW\*(C`no_auto_connect_on_new\*(C'\fR in which case \f(CW\*(C`new\*(C'\fR won't call \f(CW\*(C`$obj\->connect\*(C'\fR for you implicitly, you'll have
to do that yourself. This is useful for figuring out how long
connection setup takes so you can configure the \f(CW\*(C`cnx_timeout\*(C'\fR
appropriately.
.PP
\fI\f(CI\*(C`no_sentinels_list_update\*(C'\fI\fR
.IX Subsection "no_sentinels_list_update"
.PP
You can also provide \f(CW\*(C`no_sentinels_list_update\*(C'\fR. By default (that is,
without this option), when successfully contacting a sentinel server, the Redis
client will ask it for the list of sentinels known for the given service, and
merge it with its list of sentinels (in the \f(CW\*(C`sentinels\*(C'\fR attribute). You
can disable this behavior by setting \f(CW\*(C`no_sentinels_list_update\*(C'\fR to a true
value.
.PP
\fI\f(CI\*(C`name\*(C'\fI\fR
.IX Subsection "name"
.PP
You can also set a name for each connection. This can be very useful for
debugging purposes, using the \f(CW\*(C`CLIENT LIST\*(C'\fR command. To set a connection
name, use the \f(CW\*(C`name\*(C'\fR parameter. You can use both a scalar value or a
CodeRef. If the latter, it will be called after each connection, with the Redis
object, and it should return the connection name to use. If it returns a
undefined value, Redis will not set the connection name.
.PP
Please note that there are restrictions on the name you can set, the most
important of which is, no spaces. See the \s-1CLIENT SETNAME\s0
documentation <http://redis.io/commands/client-setname> for all the juicy
details. This feature is safe to use with all versions of Redis servers. If \f(CW\*(C`CLIENT SETNAME\*(C'\fR support is not available (Redis servers 2.6.9 and above
only), the name parameter is ignored.
.PP
\fI\f(CI\*(C`debug\*(C'\fI\fR
.IX Subsection "debug"
.PP
The \f(CW\*(C`debug\*(C'\fR parameter enables debug information to \s-1STDERR,\s0 including all
interactions with the server. You can also enable debug with the \f(CW\*(C`REDIS_DEBUG\*(C'\fR
environment variable.
.SH "CONNECTION HANDLING"
.IX Header "CONNECTION HANDLING"
.SS "connect"
.IX Subsection "connect"
.Vb 1
\&  $r\->connect;
.Ve
.PP
Connects to the Redis server. This is done by default when the obect is
constructed using \f(CW\*(C`new()\*(C'\fR, unless \f(CW\*(C`no_auto_connect_on_new\*(C'\fR has been set. See
this option in the \f(CW\*(C`new()\*(C'\fR constructor.
.SS "quit"
.IX Subsection "quit"
.Vb 1
\&  $r\->quit;
.Ve
.PP
Closes the connection to the server. The \f(CW\*(C`quit\*(C'\fR method does not support
pipelined operation.
.SS "ping"
.IX Subsection "ping"
.Vb 1
\&  $r\->ping || die "no server?";
.Ve
.PP
The \f(CW\*(C`ping\*(C'\fR method does not support pipelined operation.
.SH "PIPELINE MANAGEMENT"
.IX Header "PIPELINE MANAGEMENT"
.SS "wait_all_responses"
.IX Subsection "wait_all_responses"
Waits until all pending pipelined responses have been received, and invokes the
pipeline callback for each one.  See \*(L"\s-1PIPELINING\*(R"\s0.
.SS "wait_one_response"
.IX Subsection "wait_one_response"
Waits until the first pending pipelined response has been received, and invokes
its callback.  See \*(L"\s-1PIPELINING\*(R"\s0.
.SH "PUBLISH/SUBSCRIBE COMMANDS"
.IX Header "PUBLISH/SUBSCRIBE COMMANDS"
When one of \*(L"subscribe\*(R" or \*(L"psubscribe\*(R" is used, the Redis object will
enter \fIPubSub\fR mode. When in \fIPubSub\fR mode only commands in this section,
plus \*(L"quit\*(R", will be accepted.
.PP
If you plan on using PubSub and other Redis functions, you should use two Redis
objects, one dedicated to PubSub and the other for regular commands.
.PP
All Pub/Sub commands receive a callback as the last parameter. This callback
receives three arguments:
.IP "\(bu" 4
The published message.
.IP "\(bu" 4
The topic over which the message was sent.
.IP "\(bu" 4
The subscribed topic that matched the topic for the message. With \*(L"subscribe\*(R"
these last two are the same, always. But with \*(L"psubscribe\*(R", this parameter
tells you the pattern that matched.
.PP
See the Pub-Sub notes <http://redis.io/topics/pubsub> for more information
about the messages you will receive on your callbacks after each \*(L"subscribe\*(R",
\&\*(L"unsubscribe\*(R", \*(L"psubscribe\*(R" and \*(L"punsubscribe\*(R".
.SS "publish"
.IX Subsection "publish"
.Vb 1
\&  $r\->publish($topic, $message);
.Ve
.PP
Publishes the \f(CW$message\fR to the \f(CW$topic\fR.
.SS "subscribe"
.IX Subsection "subscribe"
.Vb 7
\&  $r\->subscribe(
\&      @topics_to_subscribe_to,
\&      my $savecallback = sub {
\&        my ($message, $topic, $subscribed_topic) = @_;
\&        ...
\&      },
\&  );
.Ve
.PP
Subscribe one or more topics. Messages published into one of them will be
received by Redis, and the specified callback will be executed.
.SS "unsubscribe"
.IX Subsection "unsubscribe"
.Vb 1
\&  $r\->unsubscribe(@topic_list, $savecallback);
.Ve
.PP
Stops receiving messages via \f(CW$savecallback\fR for all the topics in
\&\f(CW@topic_list\fR. \fB\s-1WARNING:\s0\fR it is important that you give the same calleback
that you used for subscribtion. The value of the CodeRef must be the same, as
this is how internally the code identifies it.
.SS "psubscribe"
.IX Subsection "psubscribe"
.Vb 2
\&  my @topic_matches = (\*(Aqprefix1.*\*(Aq, \*(Aqprefix2.*\*(Aq);
\&  $r\->psubscribe(@topic_matches, my $savecallback = sub { my ($m, $t, $s) = @_; ... });
.Ve
.PP
Subscribes a pattern of topics. All messages to topics that match the pattern
will be delivered to the callback.
.SS "punsubscribe"
.IX Subsection "punsubscribe"
.Vb 2
\&  my @topic_matches = (\*(Aqprefix1.*\*(Aq, \*(Aqprefix2.*\*(Aq);
\&  $r\->punsubscribe(@topic_matches, $savecallback);
.Ve
.PP
Stops receiving messages via \f(CW$savecallback\fR for all the topics pattern
matches in \f(CW@topic_list\fR. \fB\s-1WARNING:\s0\fR it is important that you give the same
calleback that you used for subscribtion. The value of the CodeRef must be the
same, as this is how internally the code identifies it.
.SS "is_subscriber"
.IX Subsection "is_subscriber"
.Vb 1
\&  if ($r\->is_subscriber) { say "We are in Pub/Sub mode!" }
.Ve
.PP
Returns true if we are in \fIPub/Sub\fR mode.
.SS "wait_for_messages"
.IX Subsection "wait_for_messages"
.Vb 3
\&  my $keep_going = 1; ## Set to false somewhere to leave the loop
\&  my $timeout = 5;
\&  $r\->wait_for_messages($timeout) while $keep_going;
.Ve
.PP
Blocks, waits for incoming messages and delivers them to the appropriate
callbacks.
.PP
Requires a single parameter, the number of seconds to wait for messages. Use 0
to wait for ever. If a positive non-zero value is used, it will return after
that amount of seconds without a single notification.
.PP
Please note that the timeout is not a commitment to return control to the
caller at most each \f(CW\*(C`timeout\*(C'\fR seconds, but more a idle timeout, were control
will return to the caller if Redis is idle (as in no messages were received
during the timeout period) for more than \f(CW\*(C`timeout\*(C'\fR seconds.
.PP
The \*(L"wait_for_messages\*(R" call returns the number of messages processed during
the run.
.SH "IMPORTANT NOTES ON METHODS"
.IX Header "IMPORTANT NOTES ON METHODS"
.SS "methods that return multiple values"
.IX Subsection "methods that return multiple values"
When a method returns more than one value, it checks the context and returns
either a list of values or an ArrayRef.
.SS "transaction-handling methods"
.IX Subsection "transaction-handling methods"
\&\fBWarning:\fR the behaviour of the \s-1TRANSACTIONS\s0 commands when combined with
pipelining is still under discussion, and you should \fB\s-1NOT\s0\fR use them at the
same time just now.
.PP
You can follow the discussion to see the open issues with
this <https://github.com/PerlRedis/perl-redis/issues/17>.
.SS "exec"
.IX Subsection "exec"
.Vb 1
\&  my @individual_replies = $r\->exec;
.Ve
.PP
\&\f(CW\*(C`exec\*(C'\fR has special behaviour when run in a pipeline: the \f(CW$reply\fR argument to
the pipeline callback is an array ref whose elements are themselves \f(CW\*(C`[$reply,
$error]\*(C'\fR pairs.  This means that you can accurately detect errors yielded by
any command in the transaction, and without any exceptions being thrown.
.SS "keys"
.IX Subsection "keys"
.Vb 2
\&  my @keys = $r\->keys( \*(Aq*glob_pattern*\*(Aq );
\&  my $keys = $r\->keys( \*(Aq*glob_pattern*\*(Aq ); # count of matching keys
.Ve
.PP
Note that synchronous \f(CW\*(C`keys\*(C'\fR calls in a scalar context return the number of
matching keys (not an array ref of matching keys as you might expect).  This
does not apply in pipelined mode: assuming the server returns a list of keys,
as expected, it is always passed to the pipeline callback as an array ref.
.SS "hashes"
.IX Subsection "hashes"
Hashes in Redis cannot be nested as in perl, if you want to store a nested
hash, you need to serialize the hash first. If you want to have a named
hash, you can use Redis-hashes. You will find an example in the tests
of this module t/01\-basic.t
.SS "eval"
.IX Subsection "eval"
Note that this commands sends the Lua script every time you call it. See
\&\*(L"evalsha\*(R" and \*(L"script_load\*(R" for an alternative.
.SS "info"
.IX Subsection "info"
.Vb 1
\&  my $info_hash = $r\->info;
.Ve
.PP
The \f(CW\*(C`info\*(C'\fR method is unique in that it decodes the server's response into a
hashref, if possible. This decoding happens in both synchronous and pipelined
modes.
.SH "KEYS"
.IX Header "KEYS"
.SS "del"
.IX Subsection "del"
.Vb 1
\&  $r\->del(key [key ...])
.Ve
.PP
Delete a key (see <http://redis.io/commands/del>)
.SS "dump"
.IX Subsection "dump"
.Vb 1
\&  $r\->dump(key)
.Ve
.PP
Return a serialized version of the value stored at the specified key. (see <http://redis.io/commands/dump>)
.SS "exists"
.IX Subsection "exists"
.Vb 1
\&  $r\->exists(key)
.Ve
.PP
Determine if a key exists (see <http://redis.io/commands/exists>)
.SS "expire"
.IX Subsection "expire"
.Vb 1
\&  $r\->expire(key, seconds)
.Ve
.PP
Set a key's time to live in seconds (see <http://redis.io/commands/expire>)
.SS "expireat"
.IX Subsection "expireat"
.Vb 1
\&  $r\->expireat(key, timestamp)
.Ve
.PP
Set the expiration for a key as a \s-1UNIX\s0 timestamp (see <http://redis.io/commands/expireat>)
.SS "keys"
.IX Subsection "keys"
.Vb 1
\&  $r\->keys(pattern)
.Ve
.PP
Find all keys matching the given pattern (see <http://redis.io/commands/keys>)
.SS "migrate"
.IX Subsection "migrate"
.Vb 1
\&  $r\->migrate(host, port, key, destination\-db, timeout, [COPY], [REPLACE])
.Ve
.PP
Atomically transfer a key from a Redis instance to another one. (see <http://redis.io/commands/migrate>)
.SS "move"
.IX Subsection "move"
.Vb 1
\&  $r\->move(key, db)
.Ve
.PP
Move a key to another database (see <http://redis.io/commands/move>)
.SS "object"
.IX Subsection "object"
.Vb 1
\&  $r\->object(subcommand, [arguments [arguments ...]])
.Ve
.PP
Inspect the internals of Redis objects (see <http://redis.io/commands/object>)
.SS "persist"
.IX Subsection "persist"
.Vb 1
\&  $r\->persist(key)
.Ve
.PP
Remove the expiration from a key (see <http://redis.io/commands/persist>)
.SS "pexpire"
.IX Subsection "pexpire"
.Vb 1
\&  $r\->pexpire(key, milliseconds)
.Ve
.PP
Set a key's time to live in milliseconds (see <http://redis.io/commands/pexpire>)
.SS "pexpireat"
.IX Subsection "pexpireat"
.Vb 1
\&  $r\->pexpireat(key, milliseconds\-timestamp)
.Ve
.PP
Set the expiration for a key as a \s-1UNIX\s0 timestamp specified in milliseconds (see <http://redis.io/commands/pexpireat>)
.SS "pttl"
.IX Subsection "pttl"
.Vb 1
\&  $r\->pttl(key)
.Ve
.PP
Get the time to live for a key in milliseconds (see <http://redis.io/commands/pttl>)
.SS "randomkey"
.IX Subsection "randomkey"
.Vb 1
\&  $r\->randomkey()
.Ve
.PP
Return a random key from the keyspace (see <http://redis.io/commands/randomkey>)
.SS "rename"
.IX Subsection "rename"
.Vb 1
\&  $r\->rename(key, newkey)
.Ve
.PP
Rename a key (see <http://redis.io/commands/rename>)
.SS "renamenx"
.IX Subsection "renamenx"
.Vb 1
\&  $r\->renamenx(key, newkey)
.Ve
.PP
Rename a key, only if the new key does not exist (see <http://redis.io/commands/renamenx>)
.SS "restore"
.IX Subsection "restore"
.Vb 1
\&  $r\->restore(key, ttl, serialized\-value)
.Ve
.PP
Create a key using the provided serialized value, previously obtained using \s-1DUMP.\s0 (see <http://redis.io/commands/restore>)
.SS "scan"
.IX Subsection "scan"
.Vb 1
\&  $r\->scan(cursor, [MATCH pattern], [COUNT count])
.Ve
.PP
Incrementally iterate the keys space (see <http://redis.io/commands/scan>)
.SS "sort"
.IX Subsection "sort"
.Vb 1
\&  $r\->sort(key, [BY pattern], [LIMIT offset count], [GET pattern [GET pattern ...]], [ASC|DESC], [ALPHA], [STORE destination])
.Ve
.PP
Sort the elements in a list, set or sorted set (see <http://redis.io/commands/sort>)
.SS "ttl"
.IX Subsection "ttl"
.Vb 1
\&  $r\->ttl(key)
.Ve
.PP
Get the time to live for a key (see <http://redis.io/commands/ttl>)
.SS "type"
.IX Subsection "type"
.Vb 1
\&  $r\->type(key)
.Ve
.PP
Determine the type stored at key (see <http://redis.io/commands/type>)
.SH "STRINGS"
.IX Header "STRINGS"
.SS "append"
.IX Subsection "append"
.Vb 1
\&  $r\->append(key, value)
.Ve
.PP
Append a value to a key (see <http://redis.io/commands/append>)
.SS "bitcount"
.IX Subsection "bitcount"
.Vb 1
\&  $r\->bitcount(key, [start end])
.Ve
.PP
Count set bits in a string (see <http://redis.io/commands/bitcount>)
.SS "bitop"
.IX Subsection "bitop"
.Vb 1
\&  $r\->bitop(operation, destkey, key [key ...])
.Ve
.PP
Perform bitwise operations between strings (see <http://redis.io/commands/bitop>)
.SS "bitpos"
.IX Subsection "bitpos"
.Vb 1
\&  $r\->bitpos(key, bit, [start], [end])
.Ve
.PP
Find first bit set or clear in a string (see <http://redis.io/commands/bitpos>)
.SS "blpop"
.IX Subsection "blpop"
.Vb 1
\&  $r\->blpop(key [key ...], timeout)
.Ve
.PP
Remove and get the first element in a list, or block until one is available (see <http://redis.io/commands/blpop>)
.SS "brpop"
.IX Subsection "brpop"
.Vb 1
\&  $r\->brpop(key [key ...], timeout)
.Ve
.PP
Remove and get the last element in a list, or block until one is available (see <http://redis.io/commands/brpop>)
.SS "brpoplpush"
.IX Subsection "brpoplpush"
.Vb 1
\&  $r\->brpoplpush(source, destination, timeout)
.Ve
.PP
Pop a value from a list, push it to another list and return it; or block until one is available (see <http://redis.io/commands/brpoplpush>)
.SS "decr"
.IX Subsection "decr"
.Vb 1
\&  $r\->decr(key)
.Ve
.PP
Decrement the integer value of a key by one (see <http://redis.io/commands/decr>)
.SS "decrby"
.IX Subsection "decrby"
.Vb 1
\&  $r\->decrby(key, decrement)
.Ve
.PP
Decrement the integer value of a key by the given number (see <http://redis.io/commands/decrby>)
.SS "get"
.IX Subsection "get"
.Vb 1
\&  $r\->get(key)
.Ve
.PP
Get the value of a key (see <http://redis.io/commands/get>)
.SS "getbit"
.IX Subsection "getbit"
.Vb 1
\&  $r\->getbit(key, offset)
.Ve
.PP
Returns the bit value at offset in the string value stored at key (see <http://redis.io/commands/getbit>)
.SS "getrange"
.IX Subsection "getrange"
.Vb 1
\&  $r\->getrange(key, start, end)
.Ve
.PP
Get a substring of the string stored at a key (see <http://redis.io/commands/getrange>)
.SS "getset"
.IX Subsection "getset"
.Vb 1
\&  $r\->getset(key, value)
.Ve
.PP
Set the string value of a key and return its old value (see <http://redis.io/commands/getset>)
.SS "incr"
.IX Subsection "incr"
.Vb 1
\&  $r\->incr(key)
.Ve
.PP
Increment the integer value of a key by one (see <http://redis.io/commands/incr>)
.SS "incrby"
.IX Subsection "incrby"
.Vb 1
\&  $r\->incrby(key, increment)
.Ve
.PP
Increment the integer value of a key by the given amount (see <http://redis.io/commands/incrby>)
.SS "incrbyfloat"
.IX Subsection "incrbyfloat"
.Vb 1
\&  $r\->incrbyfloat(key, increment)
.Ve
.PP
Increment the float value of a key by the given amount (see <http://redis.io/commands/incrbyfloat>)
.SS "mget"
.IX Subsection "mget"
.Vb 1
\&  $r\->mget(key [key ...])
.Ve
.PP
Get the values of all the given keys (see <http://redis.io/commands/mget>)
.SS "mset"
.IX Subsection "mset"
.Vb 1
\&  $r\->mset(key value [key value ...])
.Ve
.PP
Set multiple keys to multiple values (see <http://redis.io/commands/mset>)
.SS "msetnx"
.IX Subsection "msetnx"
.Vb 1
\&  $r\->msetnx(key value [key value ...])
.Ve
.PP
Set multiple keys to multiple values, only if none of the keys exist (see <http://redis.io/commands/msetnx>)
.SS "psetex"
.IX Subsection "psetex"
.Vb 1
\&  $r\->psetex(key, milliseconds, value)
.Ve
.PP
Set the value and expiration in milliseconds of a key (see <http://redis.io/commands/psetex>)
.SS "set"
.IX Subsection "set"
.Vb 1
\&  $r\->set(key, value, [\*(AqEX\*(Aq,  seconds], [\*(AqPX\*(Aq, milliseconds], [\*(AqNX\*(Aq|\*(AqXX\*(Aq])
.Ve
.PP
Set the string value of a key (see <http://redis.io/commands/set>). Example:
.PP
.Vb 1
\&  $r\->set(\*(Aqkey\*(Aq, \*(Aqtest\*(Aq, \*(AqEX\*(Aq, 60, \*(AqNX\*(Aq)
.Ve
.SS "setbit"
.IX Subsection "setbit"
.Vb 1
\&  $r\->setbit(key, offset, value)
.Ve
.PP
Sets or clears the bit at offset in the string value stored at key (see <http://redis.io/commands/setbit>)
.SS "setex"
.IX Subsection "setex"
.Vb 1
\&  $r\->setex(key, seconds, value)
.Ve
.PP
Set the value and expiration of a key (see <http://redis.io/commands/setex>)
.SS "setnx"
.IX Subsection "setnx"
.Vb 1
\&  $r\->setnx(key, value)
.Ve
.PP
Set the value of a key, only if the key does not exist (see <http://redis.io/commands/setnx>)
.SS "setrange"
.IX Subsection "setrange"
.Vb 1
\&  $r\->setrange(key, offset, value)
.Ve
.PP
Overwrite part of a string at key starting at the specified offset (see <http://redis.io/commands/setrange>)
.SS "strlen"
.IX Subsection "strlen"
.Vb 1
\&  $r\->strlen(key)
.Ve
.PP
Get the length of the value stored in a key (see <http://redis.io/commands/strlen>)
.SH "HASHES"
.IX Header "HASHES"
.SS "hdel"
.IX Subsection "hdel"
.Vb 1
\&  $r\->hdel(key, field [field ...])
.Ve
.PP
Delete one or more hash fields (see <http://redis.io/commands/hdel>)
.SS "hexists"
.IX Subsection "hexists"
.Vb 1
\&  $r\->hexists(key, field)
.Ve
.PP
Determine if a hash field exists (see <http://redis.io/commands/hexists>)
.SS "hget"
.IX Subsection "hget"
.Vb 1
\&  $r\->hget(key, field)
.Ve
.PP
Get the value of a hash field (see <http://redis.io/commands/hget>)
.SS "hgetall"
.IX Subsection "hgetall"
.Vb 1
\&  $r\->hgetall(key)
.Ve
.PP
Get all the fields and values in a hash (see <http://redis.io/commands/hgetall>)
.SS "hincrby"
.IX Subsection "hincrby"
.Vb 1
\&  $r\->hincrby(key, field, increment)
.Ve
.PP
Increment the integer value of a hash field by the given number (see <http://redis.io/commands/hincrby>)
.SS "hincrbyfloat"
.IX Subsection "hincrbyfloat"
.Vb 1
\&  $r\->hincrbyfloat(key, field, increment)
.Ve
.PP
Increment the float value of a hash field by the given amount (see <http://redis.io/commands/hincrbyfloat>)
.SS "hkeys"
.IX Subsection "hkeys"
.Vb 1
\&  $r\->hkeys(key)
.Ve
.PP
Get all the fields in a hash (see <http://redis.io/commands/hkeys>)
.SS "hlen"
.IX Subsection "hlen"
.Vb 1
\&  $r\->hlen(key)
.Ve
.PP
Get the number of fields in a hash (see <http://redis.io/commands/hlen>)
.SS "hmget"
.IX Subsection "hmget"
.Vb 1
\&  $r\->hmget(key, field [field ...])
.Ve
.PP
Get the values of all the given hash fields (see <http://redis.io/commands/hmget>)
.SS "hmset"
.IX Subsection "hmset"
.Vb 1
\&  $r\->hmset(key, field value [field value ...])
.Ve
.PP
Set multiple hash fields to multiple values (see <http://redis.io/commands/hmset>)
.SS "hscan"
.IX Subsection "hscan"
.Vb 1
\&  $r\->hscan(key, cursor, [MATCH pattern], [COUNT count])
.Ve
.PP
Incrementally iterate hash fields and associated values (see <http://redis.io/commands/hscan>)
.SS "hset"
.IX Subsection "hset"
.Vb 1
\&  $r\->hset(key, field, value)
.Ve
.PP
Set the string value of a hash field (see <http://redis.io/commands/hset>)
.SS "hsetnx"
.IX Subsection "hsetnx"
.Vb 1
\&  $r\->hsetnx(key, field, value)
.Ve
.PP
Set the value of a hash field, only if the field does not exist (see <http://redis.io/commands/hsetnx>)
.SS "hvals"
.IX Subsection "hvals"
.Vb 1
\&  $r\->hvals(key)
.Ve
.PP
Get all the values in a hash (see <http://redis.io/commands/hvals>)
.SH "SETS"
.IX Header "SETS"
.SS "sadd"
.IX Subsection "sadd"
.Vb 1
\&  $r\->sadd(key, member [member ...])
.Ve
.PP
Add one or more members to a set (see <http://redis.io/commands/sadd>)
.SS "scard"
.IX Subsection "scard"
.Vb 1
\&  $r\->scard(key)
.Ve
.PP
Get the number of members in a set (see <http://redis.io/commands/scard>)
.SS "sdiff"
.IX Subsection "sdiff"
.Vb 1
\&  $r\->sdiff(key [key ...])
.Ve
.PP
Subtract multiple sets (see <http://redis.io/commands/sdiff>)
.SS "sdiffstore"
.IX Subsection "sdiffstore"
.Vb 1
\&  $r\->sdiffstore(destination, key [key ...])
.Ve
.PP
Subtract multiple sets and store the resulting set in a key (see <http://redis.io/commands/sdiffstore>)
.SS "sinter"
.IX Subsection "sinter"
.Vb 1
\&  $r\->sinter(key [key ...])
.Ve
.PP
Intersect multiple sets (see <http://redis.io/commands/sinter>)
.SS "sinterstore"
.IX Subsection "sinterstore"
.Vb 1
\&  $r\->sinterstore(destination, key [key ...])
.Ve
.PP
Intersect multiple sets and store the resulting set in a key (see <http://redis.io/commands/sinterstore>)
.SS "sismember"
.IX Subsection "sismember"
.Vb 1
\&  $r\->sismember(key, member)
.Ve
.PP
Determine if a given value is a member of a set (see <http://redis.io/commands/sismember>)
.SS "smembers"
.IX Subsection "smembers"
.Vb 1
\&  $r\->smembers(key)
.Ve
.PP
Get all the members in a set (see <http://redis.io/commands/smembers>)
.SS "smove"
.IX Subsection "smove"
.Vb 1
\&  $r\->smove(source, destination, member)
.Ve
.PP
Move a member from one set to another (see <http://redis.io/commands/smove>)
.SS "spop"
.IX Subsection "spop"
.Vb 1
\&  $r\->spop(key)
.Ve
.PP
Remove and return a random member from a set (see <http://redis.io/commands/spop>)
.SS "srandmember"
.IX Subsection "srandmember"
.Vb 1
\&  $r\->srandmember(key, [count])
.Ve
.PP
Get one or multiple random members from a set (see <http://redis.io/commands/srandmember>)
.SS "srem"
.IX Subsection "srem"
.Vb 1
\&  $r\->srem(key, member [member ...])
.Ve
.PP
Remove one or more members from a set (see <http://redis.io/commands/srem>)
.SS "sscan"
.IX Subsection "sscan"
.Vb 1
\&  $r\->sscan(key, cursor, [MATCH pattern], [COUNT count])
.Ve
.PP
Incrementally iterate Set elements (see <http://redis.io/commands/sscan>)
.SS "sunion"
.IX Subsection "sunion"
.Vb 1
\&  $r\->sunion(key [key ...])
.Ve
.PP
Add multiple sets (see <http://redis.io/commands/sunion>)
.SS "sunionstore"
.IX Subsection "sunionstore"
.Vb 1
\&  $r\->sunionstore(destination, key [key ...])
.Ve
.PP
Add multiple sets and store the resulting set in a key (see <http://redis.io/commands/sunionstore>)
.SH "SORTED SETS"
.IX Header "SORTED SETS"
.SS "zadd"
.IX Subsection "zadd"
.Vb 1
\&  $r\->zadd(key, score member [score member ...])
.Ve
.PP
Add one or more members to a sorted set, or update its score if it already exists (see <http://redis.io/commands/zadd>)
.SS "zcard"
.IX Subsection "zcard"
.Vb 1
\&  $r\->zcard(key)
.Ve
.PP
Get the number of members in a sorted set (see <http://redis.io/commands/zcard>)
.SS "zcount"
.IX Subsection "zcount"
.Vb 1
\&  $r\->zcount(key, min, max)
.Ve
.PP
Count the members in a sorted set with scores within the given values (see <http://redis.io/commands/zcount>)
.SS "zincrby"
.IX Subsection "zincrby"
.Vb 1
\&  $r\->zincrby(key, increment, member)
.Ve
.PP
Increment the score of a member in a sorted set (see <http://redis.io/commands/zincrby>)
.SS "zinterstore"
.IX Subsection "zinterstore"
.Vb 1
\&  $r\->zinterstore(destination, numkeys, key [key ...], [WEIGHTS weight [weight ...]], [AGGREGATE SUM|MIN|MAX])
.Ve
.PP
Intersect multiple sorted sets and store the resulting sorted set in a new key (see <http://redis.io/commands/zinterstore>)
.SS "zlexcount"
.IX Subsection "zlexcount"
.Vb 1
\&  $r\->zlexcount(key, min, max)
.Ve
.PP
Count the number of members in a sorted set between a given lexicographical range (see <http://redis.io/commands/zlexcount>)
.SS "zrange"
.IX Subsection "zrange"
.Vb 1
\&  $r\->zrange(key, start, stop, [WITHSCORES])
.Ve
.PP
Return a range of members in a sorted set, by index (see <http://redis.io/commands/zrange>)
.SS "zrangebylex"
.IX Subsection "zrangebylex"
.Vb 1
\&  $r\->zrangebylex(key, min, max, [LIMIT offset count])
.Ve
.PP
Return a range of members in a sorted set, by lexicographical range (see <http://redis.io/commands/zrangebylex>)
.SS "zrangebyscore"
.IX Subsection "zrangebyscore"
.Vb 1
\&  $r\->zrangebyscore(key, min, max, [WITHSCORES], [LIMIT offset count])
.Ve
.PP
Return a range of members in a sorted set, by score (see <http://redis.io/commands/zrangebyscore>)
.SS "zrank"
.IX Subsection "zrank"
.Vb 1
\&  $r\->zrank(key, member)
.Ve
.PP
Determine the index of a member in a sorted set (see <http://redis.io/commands/zrank>)
.SS "zrem"
.IX Subsection "zrem"
.Vb 1
\&  $r\->zrem(key, member [member ...])
.Ve
.PP
Remove one or more members from a sorted set (see <http://redis.io/commands/zrem>)
.SS "zremrangebylex"
.IX Subsection "zremrangebylex"
.Vb 1
\&  $r\->zremrangebylex(key, min, max)
.Ve
.PP
Remove all members in a sorted set between the given lexicographical range (see <http://redis.io/commands/zremrangebylex>)
.SS "zremrangebyrank"
.IX Subsection "zremrangebyrank"
.Vb 1
\&  $r\->zremrangebyrank(key, start, stop)
.Ve
.PP
Remove all members in a sorted set within the given indexes (see <http://redis.io/commands/zremrangebyrank>)
.SS "zremrangebyscore"
.IX Subsection "zremrangebyscore"
.Vb 1
\&  $r\->zremrangebyscore(key, min, max)
.Ve
.PP
Remove all members in a sorted set within the given scores (see <http://redis.io/commands/zremrangebyscore>)
.SS "zrevrange"
.IX Subsection "zrevrange"
.Vb 1
\&  $r\->zrevrange(key, start, stop, [WITHSCORES])
.Ve
.PP
Return a range of members in a sorted set, by index, with scores ordered from high to low (see <http://redis.io/commands/zrevrange>)
.SS "zrevrangebylex"
.IX Subsection "zrevrangebylex"
.Vb 1
\&  $r\->zrevrangebylex(key, max, min, [LIMIT offset count])
.Ve
.PP
Return a range of members in a sorted set, by lexicographical range, ordered from higher to lower strings. (see <http://redis.io/commands/zrevrangebylex>)
.SS "zrevrangebyscore"
.IX Subsection "zrevrangebyscore"
.Vb 1
\&  $r\->zrevrangebyscore(key, max, min, [WITHSCORES], [LIMIT offset count])
.Ve
.PP
Return a range of members in a sorted set, by score, with scores ordered from high to low (see <http://redis.io/commands/zrevrangebyscore>)
.SS "zrevrank"
.IX Subsection "zrevrank"
.Vb 1
\&  $r\->zrevrank(key, member)
.Ve
.PP
Determine the index of a member in a sorted set, with scores ordered from high to low (see <http://redis.io/commands/zrevrank>)
.SS "zscan"
.IX Subsection "zscan"
.Vb 1
\&  $r\->zscan(key, cursor, [MATCH pattern], [COUNT count])
.Ve
.PP
Incrementally iterate sorted sets elements and associated scores (see <http://redis.io/commands/zscan>)
.SS "zscore"
.IX Subsection "zscore"
.Vb 1
\&  $r\->zscore(key, member)
.Ve
.PP
Get the score associated with the given member in a sorted set (see <http://redis.io/commands/zscore>)
.SS "zunionstore"
.IX Subsection "zunionstore"
.Vb 1
\&  $r\->zunionstore(destination, numkeys, key [key ...], [WEIGHTS weight [weight ...]], [AGGREGATE SUM|MIN|MAX])
.Ve
.PP
Add multiple sorted sets and store the resulting sorted set in a new key (see <http://redis.io/commands/zunionstore>)
.SH "HYPERLOGLOG"
.IX Header "HYPERLOGLOG"
.SS "pfadd"
.IX Subsection "pfadd"
.Vb 1
\&  $r\->pfadd(key, element [element ...])
.Ve
.PP
Adds the specified elements to the specified HyperLogLog. (see <http://redis.io/commands/pfadd>)
.SS "pfcount"
.IX Subsection "pfcount"
.Vb 1
\&  $r\->pfcount(key [key ...])
.Ve
.PP
Return the approximated cardinality of the set(s) observed by the HyperLogLog at key(s). (see <http://redis.io/commands/pfcount>)
.SS "pfmerge"
.IX Subsection "pfmerge"
.Vb 1
\&  $r\->pfmerge(destkey, sourcekey [sourcekey ...])
.Ve
.PP
Merge N different HyperLogLogs into a single one. (see <http://redis.io/commands/pfmerge>)
.SH "PUB/SUB"
.IX Header "PUB/SUB"
.SS "pubsub"
.IX Subsection "pubsub"
.Vb 1
\&  $r\->pubsub(subcommand, [argument [argument ...]])
.Ve
.PP
Inspect the state of the Pub/Sub subsystem (see <http://redis.io/commands/pubsub>)
.SH "TRANSACTIONS"
.IX Header "TRANSACTIONS"
.SS "discard"
.IX Subsection "discard"
.Vb 1
\&  $r\->discard()
.Ve
.PP
Discard all commands issued after \s-1MULTI\s0 (see <http://redis.io/commands/discard>)
.SS "exec"
.IX Subsection "exec"
.Vb 1
\&  $r\->exec()
.Ve
.PP
Execute all commands issued after \s-1MULTI\s0 (see <http://redis.io/commands/exec>)
.SS "multi"
.IX Subsection "multi"
.Vb 1
\&  $r\->multi()
.Ve
.PP
Mark the start of a transaction block (see <http://redis.io/commands/multi>)
.SS "unwatch"
.IX Subsection "unwatch"
.Vb 1
\&  $r\->unwatch()
.Ve
.PP
Forget about all watched keys (see <http://redis.io/commands/unwatch>)
.SS "watch"
.IX Subsection "watch"
.Vb 1
\&  $r\->watch(key [key ...])
.Ve
.PP
Watch the given keys to determine execution of the \s-1MULTI/EXEC\s0 block (see <http://redis.io/commands/watch>)
.SH "SCRIPTING"
.IX Header "SCRIPTING"
.SS "eval"
.IX Subsection "eval"
.Vb 1
\&  $r\->eval(script, numkeys, key [key ...], arg [arg ...])
.Ve
.PP
Execute a Lua script server side (see <http://redis.io/commands/eval>)
.SS "evalsha"
.IX Subsection "evalsha"
.Vb 1
\&  $r\->evalsha(sha1, numkeys, key [key ...], arg [arg ...])
.Ve
.PP
Execute a Lua script server side (see <http://redis.io/commands/evalsha>)
.SS "script_exists"
.IX Subsection "script_exists"
.Vb 1
\&  $r\->script_exists(script [script ...])
.Ve
.PP
Check existence of scripts in the script cache. (see <http://redis.io/commands/script\-exists>)
.SS "script_flush"
.IX Subsection "script_flush"
.Vb 1
\&  $r\->script_flush()
.Ve
.PP
Remove all the scripts from the script cache. (see <http://redis.io/commands/script\-flush>)
.SS "script_kill"
.IX Subsection "script_kill"
.Vb 1
\&  $r\->script_kill()
.Ve
.PP
Kill the script currently in execution. (see <http://redis.io/commands/script\-kill>)
.SS "script_load"
.IX Subsection "script_load"
.Vb 1
\&  $r\->script_load(script)
.Ve
.PP
Load the specified Lua script into the script cache. (see <http://redis.io/commands/script\-load>)
.SH "CONNECTION"
.IX Header "CONNECTION"
.SS "auth"
.IX Subsection "auth"
.Vb 1
\&  $r\->auth(password)
.Ve
.PP
Authenticate to the server (see <http://redis.io/commands/auth>)
.SS "echo"
.IX Subsection "echo"
.Vb 1
\&  $r\->echo(message)
.Ve
.PP
Echo the given string (see <http://redis.io/commands/echo>)
.SS "ping"
.IX Subsection "ping"
.Vb 1
\&  $r\->ping()
.Ve
.PP
Ping the server (see <http://redis.io/commands/ping>)
.SS "quit"
.IX Subsection "quit"
.Vb 1
\&  $r\->quit()
.Ve
.PP
Close the connection (see <http://redis.io/commands/quit>)
.SS "select"
.IX Subsection "select"
.Vb 1
\&  $r\->select(index)
.Ve
.PP
Change the selected database for the current connection (see <http://redis.io/commands/select>)
.SH "SERVER"
.IX Header "SERVER"
.SS "bgrewriteaof"
.IX Subsection "bgrewriteaof"
.Vb 1
\&  $r\->bgrewriteaof()
.Ve
.PP
Asynchronously rewrite the append-only file (see <http://redis.io/commands/bgrewriteaof>)
.SS "bgsave"
.IX Subsection "bgsave"
.Vb 1
\&  $r\->bgsave()
.Ve
.PP
Asynchronously save the dataset to disk (see <http://redis.io/commands/bgsave>)
.SS "client_getname"
.IX Subsection "client_getname"
.Vb 1
\&  $r\->client_getname()
.Ve
.PP
Get the current connection name (see <http://redis.io/commands/client\-getname>)
.SS "client_kill"
.IX Subsection "client_kill"
.Vb 1
\&  $r\->client_kill([ip:port], [ID client\-id], [TYPE normal|slave|pubsub], [ADDR ip:port], [SKIPME yes/no])
.Ve
.PP
Kill the connection of a client (see <http://redis.io/commands/client\-kill>)
.SS "client_list"
.IX Subsection "client_list"
.Vb 1
\&  $r\->client_list()
.Ve
.PP
Get the list of client connections (see <http://redis.io/commands/client\-list>)
.SS "client_pause"
.IX Subsection "client_pause"
.Vb 1
\&  $r\->client_pause(timeout)
.Ve
.PP
Stop processing commands from clients for some time (see <http://redis.io/commands/client\-pause>)
.SS "client_setname"
.IX Subsection "client_setname"
.Vb 1
\&  $r\->client_setname(connection\-name)
.Ve
.PP
Set the current connection name (see <http://redis.io/commands/client\-setname>)
.SS "cluster_slots"
.IX Subsection "cluster_slots"
.Vb 1
\&  $r\->cluster_slots()
.Ve
.PP
Get array of Cluster slot to node mappings (see <http://redis.io/commands/cluster\-slots>)
.SS "command"
.IX Subsection "command"
.Vb 1
\&  $r\->command()
.Ve
.PP
Get array of Redis command details (see <http://redis.io/commands/command>)
.SS "command_count"
.IX Subsection "command_count"
.Vb 1
\&  $r\->command_count()
.Ve
.PP
Get total number of Redis commands (see <http://redis.io/commands/command\-count>)
.SS "command_getkeys"
.IX Subsection "command_getkeys"
.Vb 1
\&  $r\->command_getkeys()
.Ve
.PP
Extract keys given a full Redis command (see <http://redis.io/commands/command\-getkeys>)
.SS "command_info"
.IX Subsection "command_info"
.Vb 1
\&  $r\->command_info(command\-name [command\-name ...])
.Ve
.PP
Get array of specific Redis command details (see <http://redis.io/commands/command\-info>)
.SS "config_get"
.IX Subsection "config_get"
.Vb 1
\&  $r\->config_get(parameter)
.Ve
.PP
Get the value of a configuration parameter (see <http://redis.io/commands/config\-get>)
.SS "config_resetstat"
.IX Subsection "config_resetstat"
.Vb 1
\&  $r\->config_resetstat()
.Ve
.PP
Reset the stats returned by \s-1INFO\s0 (see <http://redis.io/commands/config\-resetstat>)
.SS "config_rewrite"
.IX Subsection "config_rewrite"
.Vb 1
\&  $r\->config_rewrite()
.Ve
.PP
Rewrite the configuration file with the in memory configuration (see <http://redis.io/commands/config\-rewrite>)
.SS "config_set"
.IX Subsection "config_set"
.Vb 1
\&  $r\->config_set(parameter, value)
.Ve
.PP
Set a configuration parameter to the given value (see <http://redis.io/commands/config\-set>)
.SS "dbsize"
.IX Subsection "dbsize"
.Vb 1
\&  $r\->dbsize()
.Ve
.PP
Return the number of keys in the selected database (see <http://redis.io/commands/dbsize>)
.SS "debug_object"
.IX Subsection "debug_object"
.Vb 1
\&  $r\->debug_object(key)
.Ve
.PP
Get debugging information about a key (see <http://redis.io/commands/debug\-object>)
.SS "debug_segfault"
.IX Subsection "debug_segfault"
.Vb 1
\&  $r\->debug_segfault()
.Ve
.PP
Make the server crash (see <http://redis.io/commands/debug\-segfault>)
.SS "flushall"
.IX Subsection "flushall"
.Vb 1
\&  $r\->flushall()
.Ve
.PP
Remove all keys from all databases (see <http://redis.io/commands/flushall>)
.SS "flushdb"
.IX Subsection "flushdb"
.Vb 1
\&  $r\->flushdb()
.Ve
.PP
Remove all keys from the current database (see <http://redis.io/commands/flushdb>)
.SS "info"
.IX Subsection "info"
.Vb 1
\&  $r\->info([section])
.Ve
.PP
Get information and statistics about the server (see <http://redis.io/commands/info>)
.SS "lastsave"
.IX Subsection "lastsave"
.Vb 1
\&  $r\->lastsave()
.Ve
.PP
Get the \s-1UNIX\s0 time stamp of the last successful save to disk (see <http://redis.io/commands/lastsave>)
.SS "lindex"
.IX Subsection "lindex"
.Vb 1
\&  $r\->lindex(key, index)
.Ve
.PP
Get an element from a list by its index (see <http://redis.io/commands/lindex>)
.SS "linsert"
.IX Subsection "linsert"
.Vb 1
\&  $r\->linsert(key, BEFORE|AFTER, pivot, value)
.Ve
.PP
Insert an element before or after another element in a list (see <http://redis.io/commands/linsert>)
.SS "llen"
.IX Subsection "llen"
.Vb 1
\&  $r\->llen(key)
.Ve
.PP
Get the length of a list (see <http://redis.io/commands/llen>)
.SS "lpop"
.IX Subsection "lpop"
.Vb 1
\&  $r\->lpop(key)
.Ve
.PP
Remove and get the first element in a list (see <http://redis.io/commands/lpop>)
.SS "lpush"
.IX Subsection "lpush"
.Vb 1
\&  $r\->lpush(key, value [value ...])
.Ve
.PP
Prepend one or multiple values to a list (see <http://redis.io/commands/lpush>)
.SS "lpushx"
.IX Subsection "lpushx"
.Vb 1
\&  $r\->lpushx(key, value)
.Ve
.PP
Prepend a value to a list, only if the list exists (see <http://redis.io/commands/lpushx>)
.SS "lrange"
.IX Subsection "lrange"
.Vb 1
\&  $r\->lrange(key, start, stop)
.Ve
.PP
Get a range of elements from a list (see <http://redis.io/commands/lrange>)
.SS "lrem"
.IX Subsection "lrem"
.Vb 1
\&  $r\->lrem(key, count, value)
.Ve
.PP
Remove elements from a list (see <http://redis.io/commands/lrem>)
.SS "lset"
.IX Subsection "lset"
.Vb 1
\&  $r\->lset(key, index, value)
.Ve
.PP
Set the value of an element in a list by its index (see <http://redis.io/commands/lset>)
.SS "ltrim"
.IX Subsection "ltrim"
.Vb 1
\&  $r\->ltrim(key, start, stop)
.Ve
.PP
Trim a list to the specified range (see <http://redis.io/commands/ltrim>)
.SS "monitor"
.IX Subsection "monitor"
.Vb 1
\&  $r\->monitor()
.Ve
.PP
Listen for all requests received by the server in real time (see <http://redis.io/commands/monitor>)
.SS "role"
.IX Subsection "role"
.Vb 1
\&  $r\->role()
.Ve
.PP
Return the role of the instance in the context of replication (see <http://redis.io/commands/role>)
.SS "rpop"
.IX Subsection "rpop"
.Vb 1
\&  $r\->rpop(key)
.Ve
.PP
Remove and get the last element in a list (see <http://redis.io/commands/rpop>)
.SS "rpoplpush"
.IX Subsection "rpoplpush"
.Vb 1
\&  $r\->rpoplpush(source, destination)
.Ve
.PP
Remove the last element in a list, append it to another list and return it (see <http://redis.io/commands/rpoplpush>)
.SS "rpush"
.IX Subsection "rpush"
.Vb 1
\&  $r\->rpush(key, value [value ...])
.Ve
.PP
Append one or multiple values to a list (see <http://redis.io/commands/rpush>)
.SS "rpushx"
.IX Subsection "rpushx"
.Vb 1
\&  $r\->rpushx(key, value)
.Ve
.PP
Append a value to a list, only if the list exists (see <http://redis.io/commands/rpushx>)
.SS "save"
.IX Subsection "save"
.Vb 1
\&  $r\->save()
.Ve
.PP
Synchronously save the dataset to disk (see <http://redis.io/commands/save>)
.SS "shutdown"
.IX Subsection "shutdown"
.Vb 1
\&  $r\->shutdown([NOSAVE], [SAVE])
.Ve
.PP
Synchronously save the dataset to disk and then shut down the server (see <http://redis.io/commands/shutdown>)
.SS "slaveof"
.IX Subsection "slaveof"
.Vb 1
\&  $r\->slaveof(host, port)
.Ve
.PP
Make the server a slave of another instance, or promote it as master (see <http://redis.io/commands/slaveof>)
.SS "slowlog"
.IX Subsection "slowlog"
.Vb 1
\&  $r\->slowlog(subcommand, [argument])
.Ve
.PP
Manages the Redis slow queries log (see <http://redis.io/commands/slowlog>)
.SS "sync"
.IX Subsection "sync"
.Vb 1
\&  $r\->sync()
.Ve
.PP
Internal command used for replication (see <http://redis.io/commands/sync>)
.SS "time"
.IX Subsection "time"
.Vb 1
\&  $r\->time()
.Ve
.PP
Return the current server time (see <http://redis.io/commands/time>)
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
The following persons contributed to this project (random order):
.IP "\(bu" 4
Aaron Crane (pipelining and \s-1AUTOLOAD\s0 caching support)
.IP "\(bu" 4
Dirk Vleugels
.IP "\(bu" 4
Flavio Poletti
.IP "\(bu" 4
Jeremy Zawodny
.IP "\(bu" 4
sunnavy at bestpractical.com
.IP "\(bu" 4
Thiago Berlitz Rondon
.IP "\(bu" 4
Ulrich Habel
.IP "\(bu" 4
Ivan Kruglov
.IP "\(bu" 4
Steffen Mueller <smueller@cpan.org>
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Pedro Melo <melo@cpan.org>
.IP "\(bu" 4
Damien Krotkine <dams@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is Copyright (c) 2015 by Pedro Melo, Damien Krotkine.
.PP
This is free software, licensed under:
.PP
.Vb 1
\&  The Artistic License 2.0 (GPL Compatible)
.Ve
